# 1. 코드 작성규칙
- 세미콜론: 생략가능하나 문장끝에 추가 추천
- 주석 (comment): 사람용, 불필요하거나 임시테스트용 소스코드를 적용/미적용
  - 2종류
    - 한줄짜리 : // 주석내용
    - 여러줄짜리 : /* 주석내용 */
- 들여쓰기(indent): 하는 것을 권장, 가독성

# 자료형(Data Type)
- 값(Value)
- 값의 종류

# 자료형 1: 문자열(string)
- 문자열 만들기 3가지 방법
  - 1) '' : '안녕'
  - 2) "" : "안녕"
  - 3) ``(백틱): Tab키 위, \`안녕\`
    - 템플릿 문자열
    - let i =100; \`${i} 값 출력 함\`;
- 주의사항: 같은 종류의 기호로 시작, 끝나야함
- '', ' '는 다름
  - '': 빈문자열
  - ' ': 공백문자열
- typeof 연산자: 자료형을 알려주는 연산자
  - typeof 데이터(값-리터널, 변수값)
- 문자열에서 문자열생성 기호('"`)를 넣어서 사용할려면
  - 다른 종류의 문자열 생성기호 사용
    - "kim's family"
    - '영희는 "안녕"이라고 말했다'
  - Escape Sequence사용(\+문자)
    - 'kims\'s family'
- 문자열 합치기/연결하기: + 연산자
  - '문자열1' + '문자열2'

# 자료형 2: 숫자(number)
- 정수 (integer)
  - 자연수(양의 정수): 1234
  - 0
  - 음수(음의 정수): -1234
- 소수(실수, float, real number)
  - 123.456
  - 지수표기법: e ===> 10
    - 1.23456e2 ===> 1.23456*10^2
    - 1.23456e+2
    - 1.23456e-2 ===> 1.23456*10^-2
- 1234 와 "1234"
  - typeof 1234; typeof "1234";
  - 1234 == "1234 ---> true
  - 1234 === "1234 ---> false
- 진법
  - 10진법(decimal): 0~9
  - 2진법(binary): 0, 1
    - 0b0, 0b1, 0b10
  - 8진법(octet): 0~7, 18진수 8---> 10
    - 0o0,0o10
  - 16진법(hexadecimal):
    - 0~9, A(10),B(11),C(12),D(13),E(14),F(15)
    - 0x1f
- 사용자의 입력은 무조건 문자열이라 생각해야
- 사용자 입력은 prompt()함수이용
  - prompt()결과는 무조건 문자열 자료형이다.
  - 숫자를 입력받을려면 변환해야 함
    - parseInt()
      - parseInt(prompt());
      - parseInt(문자열,숫자): 숫자에 해당하는 진법으로 처리
    - parseFloat()
- NaN: Not a Number --- 숫자아님
  - typeof NaN;
- 산술 연산자
  - 가감승제: + - * /
  - 나머지: %
  - 거듭제곱: **
- 무한대: Infinity : 양의 무한대, 음의 무한대
  - 1000/0
  - typeof Infinity;
  - Infinity-Infinity = NaN
- 문자열+숫자, 숫자+문자열
  - 숫자가 문자열로 변환한 뒤 + 적용
  - "123"+456--->'123456'
- 문자열-숫자: 문자열-->숫자바뀜
  
# 연산자 우선순위
- 산술 연산
  - * / % 높고 = - 낮다
    - 3+4*5
- =, +=, -=, /=, *=... : 
  대입연산자는 우선순위 거의 최하급
- , : 최하위 순위
  - a=1, b=2;
- 최상위 우선순위 : ()
  - (3+4)*5
- 단항연산자는 우선순위 높다.
  - 부호(+-), ++, --
- 피연산자 연산자 피연산자
  - a+b
  - +a - -b

# 부동소수점 문제
- 0.1+0.2 - - - > 0.3이 아님
- 0.3-0.1 - - - > 0.2가 아님
- (0.3*10 - 0.1*10)/10 - - - > 0.2가 나옴

# 자료형: 불 값(boolean)
- true, false ---> 1, 0
  - on, off : 참, 거짓
- 비교연산자와 논리연산자의 결괏값
- >, >=,<, <=, ==, !=, ===, !==
  - == vs ===, != vs !==
  - ===, !==
    - 값 + 자료형을 함께 비교
    - 1=='1' - ---> true
    - 1==='1' ---> false
  - 문자열 비교는 사전순
  - NaN과 비교는 false 결과 
- &&(And), ||(Or), !(Not)
  - &&: 그리고
    - 피연산자가 모두가 true---> true
    - 피연산자중 하나라도 false ---> false
  - ||: 또는
    - 피연산자 모두가 false---> false
    - 피여산자중 하나라도 true---> true
  - !: 반대로
    - true ---> false
    - false ---> true
  - XOR, NOR, NAND(Not And)
- false가 되는 값들
  - !!undefined
  - !!null
  - !!0
  - !!''
  - !!NaN
  - !!false
- true가 되는 값들 : false가 되는 값들 제외
  - 123, '가나다', ' '
    condition = undefined
    if (condition){실행안되고}else{실행됨}
  - !!: 연산자??
    - !!피연산자---> 피연산자의 불 값으로 변경

# 변수 (variable)
- 변수하는 수
- 메모리에 생성
  - 스택, 힙
  - 시본자료형: 스택, 참조자료형: 힙에 생성
- 선언
  - let, const, var(old style)
  - let 생성하려는 변수명;
    - 생성하려는 변수의 값--->undefined
- 초기화
  - 선언후 최초 대입
  - 선언&초기화: let 생성하려는 변수명 = 값;
- 사용: 읽고 쓰기
  - 읽기: 변수명
  - 쓰기: 대입문 - 변수명=값;
- 변수명 작성

- 상수(constant) : 항상 같은 수
  - 변경불가
  - 1회 초기화 가능
  - const 상수명 = 초기값;
  - 상수명=값;---> error
  - 예외: 객체의 속성값은 변경가능
- var 추후 자세히

# 조건문
- if문
- if~else문
- if~else if ~ else문
- if(조건식){ // if문 블록
    실행문1; 실행문2;...실행문n;
  } else if(조건식){ // else if문 블록
    실행문1; 실행문2;...실행문n;
  } else{ // else문 블록
    실행문1; 실행문2;...실행문n;
  }

- rule base로 처리
  - if then else if then else
- 중첩 조건물
  - 조건문안에 조건문이 있는 것
- switch~case~default문
  - switch(조건식){
        case 비교조건값1; // 조건식 === 비교조건값1
            실행문1, 실행문2;...실행문n;
        break;
        case 비교조건값2;
            실행문1, 실행문2;...실행문n;
        break;
        ...
        case 비교조건값m;
            실행문1, 실행문2;...실행문n;
        break;
        default: // 앞의 case에 해당하지 않는 경우
            실행문1, 실행문2;...실행문n;
    }
- if~else if~else문 <-> switch~case~default문

- 조건 연산자
  - 피연산자1?피연산자2:피연산자3
  - 3항연산자
  - 조건식?참일때실행하는문장:거짓일때실행하는문장

# 반복문
- while, for
  - 배열: forEach(), map(), reduce()
- while: 조건이 참일 동안 반복
  - while(조건식){ // while문 블록
        실행문장1~n;
    }
- for  : 정해진 횟수만큼 반복
  - for(초기화;조건식;증감식){ //for문 블록
        실행문장1~n;
    }
- while <-> for
- 초기화;   //(1)
- while(조건식){    //(2)
    실행문장1~n;
    증감식;     //(3)
  }
- for(초기화;조건식;증감식){ //for문 블록
        실행문장1~n;
    }
- 중첩반목문
  
- break
  -  실행중 break를 실행하게 되면
  -  break가 속한 블록하나만을 종료
- continue
  -  실행중 continue를 실행하면
  -  해당 반목문 조건식 체크를 함

# 객체 (Object)
- 구성요소
  - 속성
  - 행동(기능): 메서드
- 한 묶음으로 관리할 수 있는 데이터의 모음집

- 배열
- 함수
- 배열, 함수 외의 객체

- 배열
  - [] 대괄호를 이용하여 생성
  - 요소, 원소 - element
    - 모든 데이터 타입(자료형)이 가능
    - 중복가능
  - 배열 요소 접근
    - 인덱스()위치: 숫자 0부터 시작
    - 배열명[인덱스]---> 읽기
    - 배열명[인덱스] = 값; 수정 또는 추가
    - 배열안에 배열이 있는 경우
      - 배열명[인덱스][인덱스]---> 이차원배열
  - 속성
    - length : 배열의 길이, 배열이 가지고 있는 원소의 갯수
    - 배열명.length
  - 메서드
    - 요소 추가
      - 맨 처음위치에 추가
        - 배열명.unshift(추가요소);
      - 맨 마지막위치에 추가
        - 배열명.push(추가요소);
    - 요소 삭제
      - 맨 처음
        - 배열명.shift(); // 반환값 삭제한 요소
      - 맨 마지막
        - 배열명.pop(); // 반환값 삭제한 요소
    - 배열 중간에 요소수정
      - 배열명.splice(start, amount[,추가하려는요소])
        - start~start+amount-1
    - 배열 중간에 요소 잘라서 반환받기
      - 배열명.slice(start, end)
        - start~ent-1 인덱스 범위 내용 잘라옴
    - 배열내용 검색
      - 배열명.indexOf(요소): 검색시작인덱스:0
        - 반환값
          - 존재하면 존재하는 요소의 인덱스 값
          - 비존재 : -1
      - 배열명.lastIndexOf(요소):검색시작인덱스:length-1
        - 반환값
            - 존재하면 존재하는 요소의 인덱스 값
            - 비존재 : -1
      - 배열명.includes(요소)
        - 반환값: true/false
- 함수 (function) : 기능
  - 어떤 특정 기능을 하는 코드들의 묶음
  - 재사용성, 가독성, 코드량 절약
  - 함수 정의(선언)
  1. function 함수명(파라미터들){
        실행문1; 실행문2;...실행문n;
      }
  2. const 함수명 = function(파라미터들){
        실행문1; 실행문2;...실행문n;
      }; // 무명함수
  3. const 함수명 = (파라미터들)=>{
        실행문1; 실행문2;...실행문n;
      }; // 화살표 함수(arrow function)
      // 람다식 유사
  - 함수 호출
    - 호출 전 정의되어 있어야 함
    - 함수명(아규먼트들);
    - 매개변수 - 파라미터, 인수(인자) - 아규먼트
    - 호출되면 파라미터 = 아규먼트의 대입문이 실행되고 함수 정의된 코드가 실행됨
  - 반환값
    - 호출하면 반환됨
    - 반환 위치 : 호출 한곳
    - undefined가 디폴트
    - 특정 값을 반환하려면 함수 정의 return문 사용
      - return 반환값;
- 배열, 함수 말고 객체(일반적인 객체)
  - JSON (Java Script Object Notation)
    - 자바스크립트 객체 표기법
  - XML, XML+JSON
  - 정의 : const 객체변수명 = {속성명1:속성값1, ...}
    - 객체 리터럴(구체적인 값)
    - 맨마지막 속성 뒤에 컴마(,)추가 권장
    - 속성명: 문자열
    - 속성값: 아무거나
      - 속성값: 함수이면 --> 메서드
    - 사용: 속성에 접근
      - 객체변수명.속성명1
      - 객체변수명.속성명2();
      - 객체변수명['속성명1'];
        - 연관배열: 인덱스가 숫자가 아님
  - const a = {name: 'zerocho'};
  - const c = {...a} // 복사
    - ...: spread 연산자
  - const d = JSON.parse(JSON.stringify(a)) // 복사

# DOM: Document Of Model
      웹브라우저의 자바스크립트 엔진에서 html을
      다루기 위한 라이브러리명
      HTML을 분석---> Tree로 관리
      parent : 부모
      child : 자식
      sibling : 형제 - 부모 같은
      offspring : 자손
웹프론트개발
  html: 문서의 구조
  css: 문서의 디자인
  js: 문서의 동적 변경

- DOM 처리
  - document 객체 : DOM객체
  - html문서객체
    특정 태그 선택하기
    document.getElementById(),...
    document.querySelector(선택자)
    매개변수: 선택자 - CSS 선택자 유사
      - 태그명
      - #아이디명
        태그의 id 속성값
      - .클래스명
        태그의 class 속성값
      - 태그명 > 선택자 : 자식(child)
      - 태그명 선택자 : 자손(offspring)
      - 태그명 + 선택자 : 형제(sibling)
      - ...
    반환값: 선택한 태그객체
      여러개이면 첫번째 태그객체
  - document.querySelectorAll(선택자)
    반환값: 선택한 태그객체들, 배열과 유사한 리스트

- 이벤트 처리
- Event : 사건, 컴퓨터에서 일어나는 모든 것은 이벤트
    프로그래머가 다룰 수 있는 것
      클릭, 마우스 움직임, 키보드 입력...
    그렇지 않는 것
  DOM객체에 이벤트 처리하도록 코딩
  Handler라는 용어썼지만 최근 Listener 많이씀

  DOM객체명.addEventListener(
      이벤트명, // 'click', 'mousedown', 'mousemove', 'keydown'...
      이벤트리스너함수);
  - 이벤트리스너함수명: Callback 동작
  Callback: 특정작업후 추가로 실행되는 동작
    호출 뒤에서....자바스크립트 엔진
    프로그래머가 호출하는게 아님
     